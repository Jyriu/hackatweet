import {
  setConversations,
  setMessageLoading,
  setMessageError,
  setMessagesForConversation,
  setIsFetchingMessages,
  addMessage,
  updateMessageStatus as updateMessageStatusReducer,
  setUser
} from '../Store';

import {
  emitSocketMessage,
  markConversationAsReadAction,
  sendUserTyping
} from '../middleware/socketMiddleware';

import {
  fetchConversationMessages,
  sendMessageAPI
} from '../../services/messageService';

import axios from 'axios';

// Fonction pour normaliser l'utilisateur (peut √™tre imbriqu√© ou direct)
const normalizeUser = (userObj) => {
  if (!userObj) return null;
  
  // Si userObj a une propri√©t√© user, c'est une structure imbriqu√©e
  if (userObj.user && typeof userObj.user === 'object') {
    console.log('üìã Structure utilisateur imbriqu√©e d√©tect√©e, normalisation');
    return userObj.user;
  }
  
  // Sinon c'est d√©j√† l'utilisateur direct
  return userObj;
};

// Action pour charger les messages d'une conversation sp√©cifique
export const loadConversationMessages = (conversationId) => async (dispatch, getState) => {
  // V√©rifier que l'ID de conversation est valide
  if (!conversationId) {
    console.error('‚ùå ID de conversation manquant');
    return;
  }

  console.log('‚è≥ Chargement des messages pour la conversation:', conversationId);
  
  // V√©rifier si nous sommes d√©j√† en train de r√©cup√©rer les messages
  const { isFetchingMessages } = getState().messages;
  if (isFetchingMessages) {
    console.log('üîÑ Chargement des messages d√©j√† en cours, ignor√©');
    return;
  }

  try {    
    dispatch(setIsFetchingMessages(true));
    dispatch(setMessageLoading(true));
    
    // Appel API pour r√©cup√©rer les messages
    // Attention: selon le backend, cet appel peut renvoyer un objet { messages, pagination } au lieu d'un tableau direct
    const response = await fetchConversationMessages(conversationId);
    
    // V√©rifier si la r√©ponse est un objet avec une propri√©t√© messages, ou directement un tableau
    const rawMessages = response && response.messages ? response.messages : response;
    
    console.log('‚úÖ Messages re√ßus:', rawMessages?.length || 0, rawMessages);
    
    if (!Array.isArray(rawMessages)) {
      console.error('‚ùå Format de r√©ponse invalide (messages non sous forme de tableau):', rawMessages);
      dispatch(setMessageError('Format de r√©ponse invalide du serveur'));
      dispatch(setMessageLoading(false));
      dispatch(setIsFetchingMessages(false));
      return;
    }

    // R√©cup√©rer l'ID de l'utilisateur connect√© pour d√©terminer si le message vient de lui
    let currentUser = normalizeUser(getState().user.currentUser);
    
    // Si l'utilisateur n'est pas dans le state, essayer de le r√©cup√©rer
    if (!currentUser || !currentUser._id) {
      console.warn('‚ö†Ô∏è Utilisateur non trouv√© lors du chargement des messages, tentative de r√©cup√©ration...');
      
      try {
        // V√©rifier si nous avons un token
        const token = localStorage.getItem('token');
        if (!token) {
          console.error('‚ùå Pas de token dans localStorage');
          dispatch(setMessageError('Vous devez √™tre connect√© pour voir les messages'));
          dispatch(setMessageLoading(false));
          dispatch(setIsFetchingMessages(false));
          return;
        }
        
        // Essayer de r√©cup√©rer les infos utilisateur depuis le API
        try {
          const API_URL = import.meta.env.VITE_BACKEND_URL || 'http://localhost:5001';
          const response = await axios.get(`${API_URL}/api/auth/me`, {
            headers: {
              Authorization: `Bearer ${token}`
            }
          });
          
          if (response.data && response.data._id) {
            console.log('‚úÖ Utilisateur r√©cup√©r√© depuis API:', response.data.username);
            currentUser = normalizeUser(response.data);
            
            // Mettre √† jour le state Redux avec l'utilisateur r√©cup√©r√©
            dispatch(setUser(currentUser));
          } else {
            console.error('‚ùå R√©ponse API invalide:', response.data);
            dispatch(setMessageError('Impossible de v√©rifier votre identit√©'));
            dispatch(setMessageLoading(false));
            dispatch(setIsFetchingMessages(false));
            return;
          }
        } catch (error) {
          console.error('‚ùå Erreur lors de la r√©cup√©ration de l\'utilisateur depuis API:', error);
          dispatch(setMessageError('Impossible de r√©cup√©rer votre profil'));
          dispatch(setMessageLoading(false));
          dispatch(setIsFetchingMessages(false));
          return;
        }
      } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration alternative de l\'utilisateur:', error);
        dispatch(setMessageError('Erreur d\'authentification'));
        dispatch(setMessageLoading(false));
        dispatch(setIsFetchingMessages(false));
        return;
      }
    }
    
    if (!currentUser || !currentUser._id) {
      console.error('‚ùå Utilisateur non connect√© ou sans ID');
      dispatch(setMessageError('Veuillez vous reconnecter pour voir les messages'));
      dispatch(setMessageLoading(false));
      dispatch(setIsFetchingMessages(false));
      return;
    }
    
    console.log('üë§ Utilisateur connect√©:', currentUser._id);
    
    // Traiter chaque message pour d√©terminer s'il vient de l'utilisateur courant
    // ou si cette propri√©t√© est d√©j√† d√©finie dans le message
    const processedMessages = rawMessages.map(msg => {
      // Si la propri√©t√© isFromCurrentUser est d√©j√† d√©finie, la respecter
      if (msg.isFromCurrentUser !== undefined) {
        return {
          ...msg,
          conversation: conversationId // S'assurer que l'ID de conversation est inclus
        };
      }
      
      // Sinon d√©terminer si le message vient de l'utilisateur courant
      let senderId = '';
      
      if (msg.sender) {
        senderId = typeof msg.sender === 'object' ? msg.sender._id : msg.sender;
      }
      
      const isFromCurrentUser = senderId && senderId.toString() === currentUser._id.toString();
      
      console.log(`Message ${msg._id || 'sans ID'} - Sender: ${senderId}, CurrentUser: ${currentUser._id}, isFromCurrentUser: ${isFromCurrentUser}`);
      
      return {
        ...msg,
        conversation: conversationId,
        isFromCurrentUser,
        status: msg.status || (isFromCurrentUser ? 'sent' : 'received')
      };
    });
    
    console.log('Messages trait√©s:', processedMessages);
    
    // Dispatcher les messages trait√©s
    dispatch(setMessagesForConversation({
      conversationId,
      messages: processedMessages
    }));
    
    console.log('üìù Messages trait√©s et dispatch√©s avec propri√©t√© isFromCurrentUser');
    
    // Marquer la conversation comme lue si n√©cessaire
    if (processedMessages.some(msg => !msg.isFromCurrentUser && !msg.read)) {
      dispatch(markConversationAsReadAction(conversationId));
      console.log('üìñ Marquage automatique de la conversation comme lue');
    }
    
    // S'assurer de r√©initialiser l'erreur si tout s'est bien pass√©
    dispatch(setMessageError(null));
    
    // Retourner les messages au cas o√π ils seraient n√©cessaires ailleurs
    return processedMessages;
  } catch (error) {
    console.error('‚ùå Erreur lors du chargement des messages:', error);
    dispatch(setMessageError('Impossible de charger les messages'));
    return [];
  } finally {
    dispatch(setMessageLoading(false));
    dispatch(setIsFetchingMessages(false));
  }
};

// Action pour envoyer un message
export const sendMessageAction = (conversationId, content, recipientId) => async (dispatch, getState) => {
  console.log('üì§ Envoi d\'un message:', { conversationId, content, recipientId });
  
  // V√©rifications pr√©liminaires
  if (!conversationId || !content || !recipientId) {
    console.error('‚ùå Donn√©es invalides pour l\'envoi du message', { conversationId, content, recipientId });
    return;
  }
  
  // R√©cup√©rer l'utilisateur actuel depuis le state Redux
  let currentUser = normalizeUser(getState().user.currentUser);
  
  // Si l'utilisateur n'est pas dans le state, essayer de le r√©cup√©rer du localStorage
  if (!currentUser || !currentUser._id) {
    console.warn('‚ö†Ô∏è Utilisateur non trouv√© dans le Redux state, tentative de r√©cup√©ration alternative...');
    
    try {
      // V√©rifier si nous avons un token
      const token = localStorage.getItem('token');
      if (!token) {
        console.error('‚ùå Pas de token dans localStorage, impossible d\'envoyer le message');
        return;
      }
      
      // Essayer de r√©cup√©rer les infos utilisateur depuis le API
      try {
        const API_URL = import.meta.env.VITE_BACKEND_URL || 'http://localhost:5001';
        const response = await axios.get(`${API_URL}/api/auth/me`, {
          headers: {
            Authorization: `Bearer ${token}`
          }
        });
        
        if (response.data && response.data._id) {
          console.log('‚úÖ Utilisateur r√©cup√©r√© depuis API:', response.data.username);
          currentUser = normalizeUser(response.data);
          
          // Mettre √† jour le state Redux avec l'utilisateur r√©cup√©r√©
          dispatch(setUser(currentUser));
        } else {
          console.error('‚ùå R√©ponse API invalide:', response.data);
          return;
        }
      } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration de l\'utilisateur depuis API:', error);
        return;
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©cup√©ration alternative de l\'utilisateur:', error);
      return;
    }
  }
  
  if (!currentUser || !currentUser._id) {
    console.error('‚ùå Utilisateur non connect√© ou sans ID, impossible d\'envoyer le message');
    return;
  }
  
  console.log('üë§ Utilisateur normalis√© pour envoi:', currentUser.username);
  
  // G√©n√©rer un ID temporaire unique
  const tempId = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
  
  // Cr√©er un message temporaire
  const tempMessage = {
    _id: tempId,  // ID temporaire unique
    content,
    sender: currentUser._id,
    recipient: recipientId,
    conversation: conversationId,
    createdAt: new Date().toISOString(),
    isFromCurrentUser: true,  // Important: d√©finir explicitement cette propri√©t√©
    status: 'sending',
    isTempMessage: true
  };
  
  console.log('üí¨ Message temporaire cr√©√©:', tempId);
  
  // Ajouter imm√©diatement le message temporaire au store pour l'affichage
  dispatch(addMessage({
    conversationId,
    message: tempMessage
  }));
  
  try {
    // Tenter d'abord l'envoi via WebSocket
    if (getState().socket.connected) {
      // √âmettre l'√©v√©nement socket pour envoyer le message en temps r√©el
      dispatch(emitSocketMessage(conversationId, content, recipientId));
      
      // On attend un court instant pour voir si le serveur r√©pond avec un message confirm√©
      // Si pas de confirmation apr√®s ce d√©lai, on tente l'API REST
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // V√©rifier si le message temporaire a √©t√© remplac√© par un message confirm√©
      const conversationState = getState().messages.conversations[conversationId];
      const tempMessageStillExists = conversationState?.messages?.some(m => m._id === tempId && m.status === 'sending');
      
      if (!tempMessageStillExists) {
        console.log('‚úÖ Message envoy√© avec succ√®s via WebSocket');
        return;
      }
      
      console.log('‚ö†Ô∏è Pas de confirmation WebSocket, tentative via API REST...');
    }
    
    // Envoyer le message via l'API REST
    const sentMessage = await sendMessageAPI(conversationId, content);
    console.log('‚úÖ Message envoy√© avec succ√®s via API:', sentMessage);
    
    if (!sentMessage || !sentMessage._id) {
      console.error('‚ùå R√©ponse API invalide:', sentMessage);
      throw new Error('Format de r√©ponse API invalide');
    }
    
    // Pr√©parer le message confirm√© pour remplacer le temporaire
    const confirmedMessage = {
      ...sentMessage,
      isFromCurrentUser: true,
      status: 'sent',
      _tempId: tempId  // R√©f√©rence √† l'ID temporaire pour le remplacement
    };
    
    // Dispatcher l'action pour remplacer le message temporaire
    dispatch(addMessage({
      conversationId,
      message: confirmedMessage
    }));
    
    return sentMessage;
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'envoi du message:', error);
    
    // Mettre √† jour le statut du message temporaire en "failed"
    const failedMessage = {
      ...tempMessage,
      status: 'failed'
    };
    
    dispatch(addMessage({
      conversationId,
      message: failedMessage
    }));
    
    throw error;
  }
};

// Action pour marquer un message comme lu
export const markMessageAsReadAction = (messageId) => (dispatch) => {
  console.log('üìù Marquer le message comme lu:', messageId);
  dispatch(markConversationAsReadAction(messageId));
};

// Action pour indiquer que l'utilisateur est en train de taper
export const userTypingAction = (conversationId) => (dispatch) => {
  dispatch(sendUserTyping(conversationId));
};

// Action pour mettre √† jour le statut d'un message
export const updateMessageStatusAction = (messageId, status, conversationId) => (dispatch) => {
  console.log('üìù Mise √† jour du statut du message:', { messageId, status, conversationId });
  dispatch(updateMessageStatusReducer({ messageId, status, conversationId }));
}; 